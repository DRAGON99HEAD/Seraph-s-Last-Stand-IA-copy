<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ascensão do Arcanista</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        :root {
            --primary-bg: #000000;
            --secondary-bg: #111111;
            --accent-color: #FFFFFF;
            --text-color: #FFFFFF;
            --glow-color: rgba(255, 255, 255, 0.7);
            --font-main: 'VT323', monospace;
            --danger-color: #FF4136;
            --upgrade-common: #FFFFFF;
            --upgrade-uncommon: #7FDBFF;
            --upgrade-rare: #F012BE;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--primary-bg);
            color: var(--text-color);
            font-family: var(--font-main);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            font-size: 20px;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            max-width: 1200px;
            max-height: 800px;
            box-shadow: 0 0 20px var(--glow-color);
            border: 2px solid var(--accent-color);
            border-radius: 10px;
            overflow: hidden;
            background: var(--primary-bg);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            background-color: var(--primary-bg);
        }

        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(5px);
            z-index: 10;
            text-align: center;
            padding: 10px;
            box-sizing: border-box;
        }

        .hidden {
            display: none !important;
        }

        .menu-box {
            background-color: var(--secondary-bg);
            padding: 20px 40px;
            border-radius: 0;
            border: 2px solid var(--accent-color);
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            text-align: center;
            min-width: 350px;
            max-width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .menu-box h1, .menu-box h2 {
            color: var(--accent-color);
            text-shadow: 0 0 5px var(--glow-color);
            margin-top: 0;
            font-size: 2.5em;
        }

        .menu-button, .shop-button {
            display: block;
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            background-color: transparent;
            color: var(--text-color);
            border: 2px solid var(--accent-color);
            border-radius: 0;
            font-family: var(--font-main);
            font-size: 1.5em;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .menu-button:hover, .shop-button:hover {
            background-color: var(--accent-color);
            color: var(--primary-bg);
            box-shadow: 0 0 10px var(--glow-color);
        }
        .shop-button:disabled {
            background-color: #333;
            color: #777;
            border-color: #555;
            cursor: not-allowed;
            box-shadow: none;
        }

        /* Shop and Customization Styles */
        .shop-grid, .customization-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            gap: 20px;
            margin-top: 20px;
            padding: 10px;
        }
        .item-card {
            background: var(--primary-bg);
            border: 2px solid var(--accent-color);
            padding: 15px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .item-card h3 { margin-top: 0; font-size: 1.2em; }
        .item-card p { font-size: 1em; flex-grow: 1; margin: 10px 0; }
        .item-card .price { font-weight: bold; }
        .item-card.equipped { border: 2px solid var(--upgrade-uncommon); box-shadow: 0 0 10px var(--upgrade-uncommon); }
        .price-silver { color: #c0c0c0; }
        .price-gold { color: #ffd700; }


        #in-game-ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; font-size: 22px; }
        #stats-display { position: absolute; bottom: 10px; left: 10px; background-color: rgba(0,0,0, 0.7); padding: 10px; border: 1px solid var(--accent-color); line-height: 1.2; max-width: 300px; }
        #wave-display { position: absolute; top: 10px; right: 10px; background-color: rgba(0,0,0, 0.7); padding: 10px; border: 1px solid var(--accent-color); text-align: center; }
        #health-bar-container, #xp-bar-container { position: absolute; left: 10px; height: 15px; border: 2px solid var(--accent-color); background-color: var(--primary-bg); padding: 2px; }
        #health-bar-container { top: 10px; width: 250px; }
        #xp-bar-container { top: 40px; width: 250px; }
        #health-bar-fill, #xp-bar-fill { height: 100%; transition: width 0.5s ease; }
        #health-bar-fill { background-color: var(--danger-color); }
        #xp-bar-fill { background-color: var(--upgrade-uncommon); }
        #currency-display { position: absolute; top: 10px; left: 280px; background-color: rgba(0,0,0, 0.7); padding: 5px 10px; border: 1px solid var(--accent-color); }
        
        .upgrade-grid-layout {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 20px;
            justify-content: center;
            align-content: center;
            width: fit-content;
            max-width: 900px;
        }

        .upgrade-card { background-color: var(--primary-bg); border: 2px solid; padding: 20px; margin: 10px; width: 220px; cursor: pointer; transition: all 0.2s ease; display: flex; flex-direction: column; justify-content: space-between; }
        .upgrade-card:hover { transform: scale(1.05); box-shadow: 0 0 15px; }
        .upgrade-card h3 { margin-top: 0; font-size: 1.3em; }
        .upgrade-card p { font-size: 1em; flex-grow: 1; }
        .upgrade-card .rarity { font-style: italic; font-size: 0.9em; text-align: right; }
        .rarity-Common { border-color: var(--upgrade-common); color: var(--upgrade-common); } .rarity-Common:hover { box-shadow: 0 0 15px var(--upgrade-common); }
        .rarity-Uncommon { border-color: var(--upgrade-uncommon); color: var(--upgrade-uncommon); } .rarity-Uncommon:hover { box-shadow: 0 0 15px var(--upgrade-uncommon); }
        .rarity-Rare { border-color: var(--upgrade-rare); color: var(--upgrade-rare); } .rarity-Rare:hover { box-shadow: 0 0 15px var(--upgrade-rare); }

        #debug-prompt input, #leaderboard-prompt input { padding: 10px; margin: 10px 0; width: 80%; background: var(--primary-bg); border: 2px solid var(--accent-color); color: var(--text-color); font-family: var(--font-main); font-size: 1.2em; }
        #leaderboard-table { margin: 20px auto; border-collapse: collapse; width: 95%; }
        #leaderboard-table th, #leaderboard-table td { border: 1px solid var(--accent-color); padding: 8px; }
        #leaderboard-table th { background-color: #222; }
        
        #debug-menu { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 600px; max-height: 80vh; overflow-y: auto; z-index: 100; }
        #debug-menu .menu-box { width: 100%; box-sizing: border-box; }
        #debug-menu label { display: block; margin-top: 15px; text-align: left; font-size: 1.2em; }
        #debug-menu input, #debug-menu select { width: 100%; box-sizing: border-box; padding: 10px; background: #111; border: 1px solid var(--accent-color); color: var(--text-color); font-family: var(--font-main); font-size: 1.1em; }
        #debug-menu button { font-size: 1.1em; padding: 8px; margin-top: 5px; }
        
        #boss-health-bar { position: absolute; top: 70px; left: 50%; transform: translateX(-50%); width: 80%; height: 20px; border: 2px solid var(--accent-color); background-color: var(--primary-bg); padding: 2px; }
        #boss-health-bar-fill { height: 100%; background-color: var(--danger-color); transition: width 0.5s ease; }
        
        .shooting-mode-select {
            background: var(--primary-bg);
            color: var(--text-color);
            border: 2px solid var(--accent-color);
            padding: 15px;
            font-family: var(--font-main);
            font-size: 1.5em;
            width: 100%;
            margin: 10px 0;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>

        <!-- UI In-Game -->
        <div id="in-game-ui" class="hidden">
            <div id="health-bar-container"><div id="health-bar-fill"></div></div>
            <div id="xp-bar-container"><div id="xp-bar-fill"></div></div>
            <div id="wave-display">
                <div id="wave-number">Onda: 1</div>
                <div id="wave-timer">Tempo: 00:00</div>
            </div>
            <div id="stats-display"></div>
            <div id="currency-display">
                <span id="silver-coins">Prata: 0</span> | <span id="gold-coins">Ouro: 0</span>
            </div>
            <div id="boss-health-bar" class="hidden">
                <div id="boss-health-bar-fill"></div>
            </div>
        </div>

        <!-- Menus -->
        <div id="main-menu" class="ui-overlay">
            <div class="menu-box">
                <h1>Ascensão do Arcanista</h1>
                <button id="start-game-btn" class="menu-button">Novo Jogo</button>
                <button id="shop-btn" class="menu-button">Loja</button>
                <button id="customization-btn" class="menu-button">Customização</button>
                <button id="leaderboard-btn" class="menu-button">Recordes</button>
            </div>
        </div>

        <div id="shooting-mode-menu" class="ui-overlay hidden">
            <div class="menu-box">
                <h2>Modo de Tiro</h2>
                <select id="shooting-mode-select" class="shooting-mode-select">
                    <option value="auto">Automático</option>
                    <option value="hybrid">Híbrido</option>
                    <option value="manual">Manual</option>
                </select>
                <button id="confirm-shooting-mode-btn" class="menu-button">Iniciar Jogo</button>
                <button id="back-to-main-from-shooting-btn" class="menu-button">Voltar</button>
            </div>
        </div>

        <div id="customization-menu" class="ui-overlay hidden">
            <div class="menu-box">
                <h2>Customização</h2>
                <div id="customization-content"></div>
                <button id="back-to-main-from-custom-btn" class="menu-button">Voltar</button>
            </div>
        </div>

        <div id="shop-menu" class="ui-overlay hidden">
             <div class="menu-box">
                <h2>Loja</h2>
                <div id="shop-content"></div>
                <button id="back-to-main-from-shop-btn" class="menu-button">Voltar</button>
            </div>
        </div>

        <div id="pause-menu" class="ui-overlay hidden">
            <div class="menu-box">
                <h2>Pausado</h2>
                <button id="resume-game-btn" class="menu-button">Continuar</button>
                <button id="exit-to-main-btn" class="menu-button">Sair para o Menu</button>
            </div>
        </div>

        <div id="game-over-screen" class="ui-overlay hidden">
            <div class="menu-box">
                <h2>Fim de Jogo</h2>
                <p id="game-over-stats"></p>
                <button id="restart-game-btn" class="menu-button">Tentar Novamente</button>
                <button id="game-over-to-main-btn" class="menu-button">Menu Principal</button>
            </div>
        </div>
        
        <div id="upgrade-screen" class="ui-overlay hidden"></div>

        <div id="debug-prompt" class="ui-overlay hidden">
            <div class="menu-box">
                <h2>Prompt de Comando</h2>
                <input type="text" id="debug-code-input" placeholder="Insira o código...">
                <button id="submit-debug-code-btn" class="menu-button">Confirmar</button>
                <button id="cancel-debug-prompt-btn" class="menu-button">Cancelar</button>
            </div>
        </div>

        <div id="debug-menu" class="hidden">
            <div class="menu-box">
                <h2>DEBUG MODE</h2>
                
                <hr>
                <h3>Jogador</h3>
                <button id="heal-player-btn" class="menu-button">Curar Jogador</button>
                <button id="toggle-god-mode-btn" class="menu-button">God Mode: OFF</button>
                <button id="add-xp-btn" class="menu-button">Add 1000 XP</button>
                <button id="add-coins-btn" class="menu-button">Add 10k Moedas</button>

                <hr>
                <h3>Melhorias</h3>
                <label for="debug-upgrade-select">Dar Upgrade Específico:</label>
                <select id="debug-upgrade-select"></select>
                <button id="add-upgrade-btn" class="menu-button">Adicionar Upgrade</button>
                <button id="give-all-upgrades-btn" class="menu-button">Dar Todos os Upgrades</button>

                <hr>
                <h3>Mundo</h3>
                <label for="debug-wave-input">Ir para Onda:</label>
                <input type="number" id="debug-wave-input" value="10">
                <button id="goto-wave-btn" class="menu-button">Ir para Onda</button>
                <button id="kill-enemies-btn" class="menu-button">Matar Inimigos</button>
                <button id="spawn-boss-btn" class="menu-button">Invocar Chefe</button>

                <hr>
                <button id="close-debug-menu-btn" class="menu-button" style="border-color: var(--danger-color); color: var(--danger-color); margin-top: 20px;">Fechar</button>
            </div>
        </div>

        <div id="victory-screen" class="ui-overlay hidden">
            <div class="menu-box">
                <h2>VITÓRIA!</h2>
                <p>Você derrotou o Arcanista Ancestral!</p>
                <p id="victory-stats"></p>
                <hr>
                <p>Créditos:</p>
                <p><strong>DRAGON HEAD</strong> (Ideias)</p>
                <p><strong>GEMINI</strong> (Programação e Gráficos)</p>
                <hr>
                <p>Insira seu nome para a Tabela de Recordes:</p>
                <input type="text" id="leaderboard-name-input" placeholder="Seu Nome">
                <button id="submit-score-btn" class="menu-button">Enviar Recorde</button>
            </div>
        </div>

        <div id="leaderboard-screen" class="ui-overlay hidden">
            <div class="menu-box">
                <h2>Tabela de Recordes</h2>
                <table id="leaderboard-table">
                    <thead><tr><th>Rank</th><th>Nome</th><th>Onda</th><th>Tempo</th><th>Status</th></tr></thead>
                    <tbody id="leaderboard-body"></tbody>
                </table>
                <button id="leaderboard-back-btn" class="menu-button">Voltar</button>
            </div>
        </div>
    </div>

    <script>
        // This script encapsulates the entire game logic for "Ascensão do Arcanista".
        window.onload = () => {
            // --- DOM ELEMENTS ---
            const ui = {
                canvas: document.getElementById('gameCanvas'),
                ctx: document.getElementById('gameCanvas').getContext('2d'),
                container: document.getElementById('game-container'),
                
                // Menus
                mainMenu: document.getElementById('main-menu'),
                shootingModeMenu: document.getElementById('shooting-mode-menu'),
                customizationMenu: document.getElementById('customization-menu'),
                shopMenu: document.getElementById('shop-menu'),
                pauseMenu: document.getElementById('pause-menu'),
                
                // Screens
                gameOverScreen: document.getElementById('game-over-screen'),
                upgradeScreen: document.getElementById('upgrade-screen'),
                victoryScreen: document.getElementById('victory-screen'),
                leaderboardScreen: document.getElementById('leaderboard-screen'),
                
                // Debug
                debugPrompt: document.getElementById('debug-prompt'),
                debugMenu: document.getElementById('debug-menu'),
                
                // In-Game UI
                inGameUI: document.getElementById('in-game-ui'),
                healthBarFill: document.getElementById('health-bar-fill'),
                xpBarFill: document.getElementById('xp-bar-fill'),
                waveNumber: document.getElementById('wave-number'),
                waveTimer: document.getElementById('wave-timer'),
                statsDisplay: document.getElementById('stats-display'),
                silverCoins: document.getElementById('silver-coins'),
                goldCoins: document.getElementById('gold-coins'),
                bossHealthBar: document.getElementById('boss-health-bar'),
                bossHealthBarFill: document.getElementById('boss-health-bar-fill'),
            };

            // --- GAME STATE ---
            let gameState = 'MAIN_MENU';
            let gameLoopId;
            let keys = {};
            let mouse = { x: 0, y: 0, down: false };
            let player, camera, waveManager, boss;
            let projectiles = [], enemies = [], particles = [], platforms = [], wisps = [], orbs = [];
            let gameTime = 0, lastTime = 0, waveTime = 0;
            let bossSpawned = false;
            let godMode = false;
            let screenShake = 0;
            let backgroundLayers = [];

            // --- CONFIG & DATA ---
            const DEBUG_CODE = "ANDREYOUNG";
            const BOSS_SPAWN_Y = -15000;
            const GRAVITY = 0.7;
            const WORLD_WIDTH = 4000;
            const WORLD_HEIGHT = 16000;

            // --- ITEM DATABASES ---
            const SKINS = {
                default: { name: 'Arcanista Padrão', price: 0, ability: (p) => {}, drawProps: { stroke: '#FFFFFF', fill: '#00FFFF' } },
                crimson: { name: 'Arcanista Carmesim', price: 100, currency: 'silver', ability: (p) => { p.stats.damageMultiplier = 1.05; }, drawProps: { stroke: '#FF4136', fill: '#FF851B' } },
                emerald: { name: 'Sábio Esmeralda', price: 100, currency: 'silver', ability: (p) => { p.stats.passiveRegen = 0.2; }, drawProps: { stroke: '#2ECC40', fill: '#01FF70' } },
                golden: { name: 'Mago Dourado', price: 10, currency: 'gold', ability: (p) => { p.stats.coinMultiplier = 1.15; }, drawProps: { stroke: '#FFDC00', fill: '#F012BE' } },
            };
            const WEAPONS = {
                default: {
                    name: 'Cajado Padrão', desc: 'Um cajado confiável.', price: 0,
                    shoot: (p, angle) => {
                        projectiles.push(new Projectile(p.x, p.y, angle, p, 'player'));
                    }
                },
                shotgun: {
                    name: 'Cajado Dispersor', desc: 'Atira 3 projéteis em cone.', price: 250, currency: 'silver',
                    shoot: (p, angle) => {
                        const spread = 0.4; const pellets = 3;
                        for (let i = 0; i < pellets; i++) {
                            const newAngle = angle - (spread / 2) + (i * (spread / (pellets - 1)));
                            projectiles.push(new Projectile(p.x, p.y, newAngle, p, 'player'));
                        }
                    }
                },
                beam: {
                    name: 'Cajado de Raio', desc: 'Atira um raio perfurante.', price: 500, currency: 'silver',
                    shoot: (p, angle) => {
                        const proj = new Projectile(p.x, p.y, angle, p, 'player');
                        proj.isBeam = true;
                        proj.piercingLeft = 999;
                        proj.radius = p.stats.projectileSizeMultiplier * 4;
                        proj.ttl = 20; // Lasts for 20 frames
                        projectiles.push(proj);
                    }
                },
            };
            const UPGRADES = {
                // Common
                "Catalyst": { name: "Catalyst", desc: "Dano do projétil +2", rarity: "Common", apply: p => p.stats.projectileDamage += 2 },
                "Eyesight": { name: "Eyesight", desc: "Chance de Crítico +5%", rarity: "Common", apply: p => p.stats.critChance += 0.05 },
                "Growth": { name: "Growth", desc: "Vida Máxima +10", rarity: "Common", apply: p => { p.stats.maxHp += 10; p.heal(10); } },
                "Impulse": { name: "Impulse", desc: "Altura do Pulo +20%", rarity: "Common", apply: p => p.stats.jumpForceMultiplier += 0.2 },
                "Renew": { name: "Renew", desc: "Cura toda a vida", rarity: "Common", apply: p => p.heal(p.stats.maxHp) },
                "Resist": { name: "Resist", desc: "Defesa +4%", rarity: "Common", apply: p => p.stats.defense += 0.04 },
                "Resonance": { name: "Resonance", desc: "Vel. de Ataque +12%", rarity: "Common", apply: p => p.stats.attackSpeedMultiplier -= 0.12 },
                "Souls": { name: "Souls", desc: "Inimigos derrubam mais XP", rarity: "Common", apply: p => p.stats.xpGainMultiplier += 0.15 },
                "Stability": { name: "Stability", desc: "Projétil atravessa +1 inimigo", rarity: "Common", apply: p => p.stats.projectilePiercing++ },
                "Swift": { name: "Swift", desc: "Vel. de Movimento +15%", rarity: "Common", apply: p => p.stats.speedMultiplier += 0.15 },
                // Uncommon
                "Catalyst+": { name: "Catalyst+", desc: "Dano do projétil +4", rarity: "Uncommon", apply: p => p.stats.projectileDamage += 4 },
                "Charge": { name: "Charge", desc: "Tamanho do Projétil +20%", rarity: "Uncommon", apply: p => p.stats.projectileSizeMultiplier += 0.2 },
                "Cloak": { name: "Cloak", desc: "Invulnerabilidade após dano +0.2s", rarity: "Uncommon", apply: p => p.stats.invulnerabilityDuration += 200 },
                "Fragmentation": { name: "Fragmentation", desc: "Inimigos explodem em 2 projéteis ao morrer", rarity: "Uncommon", apply: p => p.stats.enemyFragmentation += 2 },
                "Growth+": { name: "Growth+", desc: "Vida Máxima +20", rarity: "Uncommon", apply: p => { p.stats.maxHp += 20; p.heal(20); } },
                "Gush": { name: "Gush", desc: "+1 Pulo", rarity: "Uncommon", apply: p => p.stats.extraJumps++ },
                "Leech": { name: "Leech", desc: "Roubo de Vida de 3% do Dano", rarity: "Uncommon", apply: p => p.stats.lifesteal += 0.03 },
                "Luck": { name: "Luck", desc: "Maior chance de melhorias raras", rarity: "Uncommon", apply: p => p.stats.luck += 0.1 },
                "Orb": { name: "Orb", desc: "Inimigos tem 5% de chance de dropar um orbe de cura", rarity: "Uncommon", apply: p => p.stats.healOrbChance += 0.05 },
                "Precision": { name: "Precision", desc: "Dano de Crítico +50%", rarity: "Uncommon", apply: p => p.stats.critDamageMultiplier += 0.5 },
                "Rage": { name: "Rage", desc: "Abaixo de 50% HP, aumenta o dano (até 50%)", rarity: "Uncommon", apply: p => p.stats.hasRage = true },
                "Regrowth": { name: "Regrowth", desc: "Regenera 0.1 HP/s por inimigo vivo", rarity: "Uncommon", apply: p => p.stats.regrowthRate += 0.1 },
                "Resonance+": { name: "Resonance+", desc: "Vel. de Ataque +24%", rarity: "Uncommon", apply: p => p.stats.attackSpeedMultiplier -= 0.24 },
                "Shrink": { name: "Shrink", desc: "Fica 10% menor", rarity: "Uncommon", apply: p => { p.sizeMultiplier -= 0.1; p.width = 32 * p.sizeMultiplier; p.height = 48 * p.sizeMultiplier; } },
                "Swift+": { name: "Swift+", desc: "Vel. de Movimento +30%", rarity: "Uncommon", apply: p => p.stats.speedMultiplier += 0.30 },
                "Thunderbolt": { name: "Thunderbolt", desc: "Chama 2 raios dos céus a cada 5s", rarity: "Uncommon", apply: p => p.stats.thunderbolts += 2 },
                // Rare
                "Appraisal": { name: "Appraisal", desc: "+1 escolha de melhoria", rarity: "Rare", apply: p => p.stats.upgradeChoices++ },
                "Barrier": { name: "Barrier", desc: "Cria um escudo que bloqueia dano a cada 15s", rarity: "Rare", apply: p => p.stats.hasBarrier = true },
                "Cold": { name: "Cold", desc: "Inimigos ficam 1% mais lentos por acerto (máx 80%)", rarity: "Rare", apply: p => p.stats.slowOnHit += 0.01 },
                "Fragmentation+": { name: "Fragmentation+", desc: "Inimigos explodem em 6 projéteis ao morrer", rarity: "Rare", apply: p => p.stats.enemyFragmentation += 4 },
                "Focus": { name: "Focus", desc: "Ganha vel. de ataque ao ficar parado. Reseta ao mover.", rarity: "Rare", apply: p => p.stats.hasFocus = true },
                "Growth++": { name: "Growth++", desc: "Vida Máxima +40", rarity: "Rare", apply: p => { p.stats.maxHp += 40; p.heal(40); } },
                "Leech+": { name: "Leech+", desc: "Roubo de Vida de 9% do Dano", rarity: "Rare", apply: p => p.stats.lifesteal += 0.06 },
                "Overheat": { name: "Overheat", desc: "Seu corpo causa 40 de dano por contato", rarity: "Rare", apply: p => p.stats.bodyDamage += 40 },
                "Thunderbolt+": { name: "Thunderbolt+", desc: "Chama 6 raios dos céus a cada 5s", rarity: "Rare", apply: p => p.stats.thunderbolts += 4 },
                "Tome": { name: "Tome", desc: "Novas melhorias comuns são 35% mais efetivas", rarity: "Rare", apply: p => p.stats.tomeMultiplier += 0.35 },
                "Will-O-Wisp": { name: "Will-O-Wisp", desc: "Invoca um wisp que ataca com você", rarity: "Rare", apply: p => { if (wisps.length === 0) { wisps.push(new Wisp(p)); } } },
                "Wound": { name: "Wound", desc: "Aplica sangramento nos inimigos (dano ao longo do tempo)", rarity: "Rare", apply: p => p.stats.bleedChance += 0.25 },
            };
            
            // --- GAME CLASSES ---

            class Player {
                constructor(x, y) {
                    this.sizeMultiplier = 1;
                    this.width = 32 * this.sizeMultiplier;
                    this.height = 48 * this.sizeMultiplier;
                    this.x = x - this.width / 2;
                    this.y = y - this.height;
                    this.vx = 0; this.vy = 0;
                    this.onGround = false;
                    this.jumpsLeft = 0;
                    this.lastShot = 0;
                    this.level = 1;
                    this.xp = 0;
                    this.xpToNextLevel = 100;
                    this.isInvulnerable = false;
                    this.invulnerableTimer = 0;
                    this.upgrades = [];
                    this.focusBonus = 0;
                    this.standStillTimer = 0;
                    this.barrierCooldown = 0;
                    this.barrierActive = false;
                    this.thunderboltTimer = 0;

                    this.stats = this.resetStats();
                    this.hp = this.stats.maxHp;
                }

                resetStats() {
                    return {
                        speed: 5, jumpForce: 16, maxHp: 100, projectileDamage: 10, attackSpeed: 500, critChance: 0.05,
                        speedMultiplier: 1, jumpForceMultiplier: 1, attackSpeedMultiplier: 1, projectileSizeMultiplier: 1,
                        damageMultiplier: 1,
                        projectilePiercing: 1, defense: 0, lifesteal: 0, critDamageMultiplier: 2, extraJumps: 0,
                        healOrbChance: 0, xpGainMultiplier: 1, invulnerabilityDuration: 500, enemyFragmentation: 0,
                        hasRage: false, regrowthRate: 0, passiveRegen: 0, coinMultiplier: 1, hasBarrier: false, slowOnHit: 0, hasFocus: false,
                        bodyDamage: 0, thunderbolts: 0, tomeMultiplier: 1, bleedChance: 0, luck: 0, upgradeChoices: 3,
                        unlockedSkins: ['default'], unlockedWeapons: ['default'],
                        equippedSkin: 'default', equippedWeapon: 'default',
                        silver: 0, gold: 0
                    };
                }

                applyLoadedData(data) {
                    this.stats.silver = data.silver || 0;
                    this.stats.gold = data.gold || 0;
                    this.stats.unlockedSkins = data.unlockedSkins || ['default'];
                    this.stats.unlockedWeapons = data.unlockedWeapons || ['default'];
                    this.stats.equippedSkin = data.equippedSkin || 'default';
                    this.stats.equippedWeapon = data.equippedWeapon || 'default';
                }

                update(deltaTime) {
                    // Movement
                    const currentSpeed = this.stats.speed * this.stats.speedMultiplier;
                    let moved = false;
                    if (keys['a'] || keys['ArrowLeft']) { this.vx = -currentSpeed; moved = true; }
                    else if (keys['d'] || keys['ArrowRight']) { this.vx = currentSpeed; moved = true; }
                    else { this.vx = 0; }

                    if (!moved) { this.standStillTimer += deltaTime; } 
                    else { this.standStillTimer = 0; this.focusBonus = 0; }

                    // Jumping
                    if (this.onGround) { this.jumpsLeft = 1 + this.stats.extraJumps; }
                    if ((keys['w'] || keys['ArrowUp'] || keys[' ']) && this.jumpsLeft > 0) {
                        this.vy = -this.stats.jumpForce * this.stats.jumpForceMultiplier;
                        this.onGround = false;
                        this.jumpsLeft--;
                        keys['w'] = keys['ArrowUp'] = keys[' '] = false; // Consume jump input
                    }

                    // Physics
                    this.vy += GRAVITY;
                    this.x += this.vx;
                    this.y += this.vy;
                    this.onGround = false;

                    // Platform Collision
                    platforms.forEach(p => {
                        if (this.x < p.x + p.width && this.x + this.width > p.x && 
                            this.y + this.height >= p.y && this.y + this.height <= p.y + p.height + this.vy && this.vy >= 0) {
                            this.y = p.y - this.height;
                            this.vy = 0;
                            this.onGround = true;
                        }
                    });
                    
                    // World bounds
                    if (this.x < 0) this.x = 0;
                    if (this.x + this.width > WORLD_WIDTH) this.x = WORLD_WIDTH - this.width;

                    // Shooting
                    const shootingMode = document.getElementById('shooting-mode-select').value;
                    const now = Date.now();
                    let finalAttackSpeed = this.stats.attackSpeed * this.stats.attackSpeedMultiplier * (1 - this.focusBonus);
                    if (now - this.lastShot > finalAttackSpeed) {
                        if (shootingMode === 'auto' || (shootingMode === 'hybrid' && mouse.down) || (shootingMode === 'manual' && mouse.down)) {
                            this.shoot();
                            this.lastShot = now;
                        }
                    }

                    // Update timers and special abilities
                    if (this.isInvulnerable) {
                        this.invulnerableTimer -= deltaTime * 1000;
                        if (this.invulnerableTimer <= 0) this.isInvulnerable = false;
                    }
                    
                    // Stats updates
                    if (this.stats.regrowthRate > 0) {
                        this.heal(this.stats.regrowthRate * enemies.length * deltaTime);
                    }
                    if (this.stats.passiveRegen > 0) {
                        this.heal(this.stats.passiveRegen * deltaTime);
                    }
                    if (this.stats.hasBarrier) {
                        if (!this.barrierActive) {
                            this.barrierCooldown -= deltaTime;
                            if (this.barrierCooldown <= 0) {
                                this.barrierActive = true;
                                this.barrierCooldown = 15; // 15s cooldown
                            }
                        }
                    }
                    if (this.stats.hasFocus && this.standStillTimer > 1) {
                        this.focusBonus = Math.min(0.75, this.focusBonus + deltaTime * 0.1); // up to 75% faster
                    }
                    if (this.stats.thunderbolts > 0) {
                        this.thunderboltTimer -= deltaTime;
                        if (this.thunderboltTimer <= 0) {
                            for(let i = 0; i < this.stats.thunderbolts; i++) {
                                if(enemies.length > 0) {
                                    const target = enemies[Math.floor(Math.random() * enemies.length)];
                                    projectiles.push(new Thunderbolt(target.x, target.y, this));
                                }
                            }
                            this.thunderboltTimer = 5; // 5s cooldown
                        }
                    }

                    // Check for boss spawn
                    if (this.y < BOSS_SPAWN_Y && !bossSpawned) {
                        spawnBoss();
                    }
                }

                draw(ctx) {
                    const drawX = this.x;
                    const drawY = this.y;
                    
                    ctx.globalAlpha = this.isInvulnerable ? 0.5 : 1.0;
                    ctx.lineWidth = 2;
                    
                    const skinData = SKINS[this.stats.equippedSkin] || SKINS.default;
                    ctx.strokeStyle = skinData.drawProps.stroke;
                    ctx.fillStyle = skinData.drawProps.fill;

                    // Draw a more detailed wizard sprite
                    // Hat
                    ctx.beginPath();
                    ctx.moveTo(drawX + this.width * 0.1, drawY + this.height * 0.2);
                    ctx.lineTo(drawX + this.width * 0.9, drawY + this.height * 0.2);
                    ctx.lineTo(drawX + this.width * 0.5, drawY - this.height * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    // Head
                    ctx.beginPath();
                    ctx.arc(drawX + this.width / 2, drawY + this.height * 0.25, this.width * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();

                    // Robe
                    ctx.beginPath();
                    ctx.moveTo(drawX + this.width * 0.5, drawY + this.height * 0.35);
                    ctx.lineTo(drawX, drawY + this.height);
                    ctx.lineTo(drawX + this.width, drawY + this.height);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    ctx.globalAlpha = 1.0;
                    
                    if (this.barrierActive) {
                        ctx.beginPath();
                        ctx.arc(drawX + this.width / 2, drawY + this.height / 2, this.width, 0, Math.PI * 2);
                        ctx.strokeStyle = 'rgba(0, 255, 255, 0.8)';
                        ctx.lineWidth = 3;
                        ctx.stroke();
                    }
                }

                shoot() {
                    let targetX, targetY;
                    const shootingMode = document.getElementById('shooting-mode-select').value;
                    
                    if (shootingMode === 'auto') {
                        let closestTarget = null;
                        let minDistance = Infinity;
                        const potentialTargets = [...enemies, ...(boss ? [boss] : [])];
                        potentialTargets.forEach(e => {
                            const dist = Math.hypot(e.x - this.x, e.y - this.y);
                            if (dist < minDistance) {
                                minDistance = dist;
                                closestTarget = e;
                            }
                        });
                        if (closestTarget) {
                            targetX = closestTarget.x + closestTarget.width / 2;
                            targetY = closestTarget.y + closestTarget.height / 2;
                        } else {
                            targetX = mouse.x + camera.x;
                            targetY = mouse.y + camera.y;
                        }
                    } else { // Manual or Hybrid
                        targetX = mouse.x + camera.x;
                        targetY = mouse.y + camera.y;
                    }

                    const angle = Math.atan2(targetY - (this.y + this.height / 2), targetX - (this.x + this.width / 2));
                    const weapon = WEAPONS[this.stats.equippedWeapon] || WEAPONS.default;
                    weapon.shoot(this, angle);
                }

                takeDamage(amount) {
                    if (this.isInvulnerable || godMode) return;
                    screenShake = 10;
                    if (this.barrierActive) {
                        this.barrierActive = false;
                        return;
                    }
                    
                    const finalDamage = Math.max(1, amount * (1 - this.stats.defense));
                    this.hp -= finalDamage;
                    this.isInvulnerable = true;
                    this.invulnerableTimer = this.stats.invulnerabilityDuration;
                    
                    for(let i=0; i<10; i++) particles.push(new Particle(this.x + this.width/2, this.y + this.height/2, '#a22c2c'));

                    if (this.hp <= 0) {
                        this.hp = 0;
                        setGameState('GAME_OVER');
                    }
                }

                heal(amount) {
                    this.hp = Math.min(this.stats.maxHp, this.hp + amount);
                }

                addXp(amount) {
                    this.xp += amount * this.stats.xpGainMultiplier;
                    while (this.xp >= this.xpToNextLevel) {
                        this.levelUp();
                    }
                }

                levelUp() {
                    this.xp -= this.xpToNextLevel;
                    this.level++;
                    this.xpToNextLevel = Math.floor(this.xpToNextLevel * 1.25);
                    this.heal(this.stats.maxHp * 0.25); // Heal 25% on level up
                    setGameState('LEVEL_UP');
                }
                
                applyUpgrade(upgrade) {
                    let effectiveUpgrade = upgrade;
                    if (upgrade.rarity === "Common" && this.stats.tomeMultiplier > 1) {
                        console.log("Tome active, but simple re-application is used.");
                    }
                    
                    effectiveUpgrade.apply(this);
                    this.upgrades.push(upgrade.name);
                    updateStatsUI();
                }
            }

            class Projectile {
                constructor(x, y, angle, owner, ownerType) {
                    this.ownerType = ownerType; // 'player' or 'enemy'
                    this.x = x; this.y = y;
                    this.radius = 4 * (owner.stats?.projectileSizeMultiplier || 1);
                    this.speed = 12;
                    this.vx = Math.cos(angle) * this.speed;
                    this.vy = Math.sin(angle) * this.speed;
                    this.isCrit = Math.random() < (owner.stats?.critChance || 0);
                    this.lightRadius = this.radius * 5;
                    
                    let damage = (owner.stats?.projectileDamage || 5) * (owner.stats?.damageMultiplier || 1);
                    if (this.ownerType === 'player' && owner.stats.hasRage && owner.hp < owner.stats.maxHp / 2) {
                        const rageBonus = 1 + (1 - (owner.hp / (owner.stats.maxHp / 2)));
                        damage *= rageBonus;
                    }
                    if (this.isCrit) {
                        damage *= (owner.stats?.critDamageMultiplier || 2);
                    }
                    this.damage = damage;
                    
                    this.piercingLeft = owner.stats?.projectilePiercing || 1;
                    this.ttl = 300;
                    this.isBeam = false;
                }

                update() {
                    this.x += this.vx;
                    this.y += this.vy;
                    this.ttl--;
                }

                draw(ctx) {
                    ctx.beginPath();
                    if(this.isBeam) {
                        ctx.strokeStyle = this.isCrit ? '#b45f93' : '#6c9c9d';
                        ctx.lineWidth = this.radius * 2;
                        ctx.moveTo(this.x, this.y);
                        ctx.lineTo(this.x - this.vx * 2, this.y - this.vy * 2);
                        ctx.stroke();
                    } else {
                        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                        if (this.ownerType === 'enemy') {
                            ctx.fillStyle = '#d14a4a';
                        } else {
                            ctx.fillStyle = this.isCrit ? '#b45f93' : '#d4c8b8';
                        }
                        ctx.fill();
                    }
                }
            }

            class Thunderbolt extends Projectile {
                constructor(x, y, owner) {
                    super(x, y - 500, Math.PI / 2, owner, 'player');
                    this.damage *= 1.5; // Thunderbolts are stronger
                    this.ttl = 30;
                }
                draw(ctx) {
                    ctx.strokeStyle = '#e8b923';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    let lx = this.x;
                    let ly = this.y;
                    ctx.moveTo(lx, ly);
                    for(let i=0; i<10; i++) {
                        lx += (Math.random() - 0.5) * 40;
                        ly += 50;
                        ctx.lineTo(lx, ly);
                    }
                    ctx.stroke();
                }
            }

            class Enemy {
                constructor(x, y, wave) {
                    this.width = 35;
                    this.height = 35;
                    this.x = x; this.y = y;
                    const difficulty = 1 + (wave * 0.1) + (gameTime / 60000);
                    this.speed = (1.5 + Math.random()) * Math.min(3, difficulty * 0.5);
                    this.maxHp = Math.floor(20 * difficulty);
                    this.hp = this.maxHp;
                    this.damage = Math.floor(5 * difficulty);
                    this.xpValue = Math.floor(10 * difficulty);
                    this.slowFactor = 1;
                    this.bleedTicks = 0;

                    this.preferredDistance = 250 + Math.random() * 100;
                    this.lastShot = 0;
                    this.shootCooldown = 2000; // 2 seconds
                    this.stats = { projectileDamage: 5 * difficulty * 0.5 };
                }

                update(deltaTime) {
                    if (!player) return;
                    const dist = Math.hypot(player.x - this.x, player.y - this.y);
                    const angle = Math.atan2(player.y - this.y, player.x - this.x);

                    if (dist > this.preferredDistance) {
                        this.x += Math.cos(angle) * this.speed * this.slowFactor;
                        this.y += Math.sin(angle) * this.speed * this.slowFactor;
                    } else {
                        // Close enough, start shooting
                        const now = Date.now();
                        if (now - this.lastShot > this.shootCooldown) {
                            this.shoot(angle);
                            this.lastShot = now;
                        }
                    }

                    if (this.bleedTicks > 0) {
                        this.takeDamage(this.bleedDamage, true);
                        this.bleedTicks--;
                    }
                }
                
                shoot(angle) {
                    projectiles.push(new Projectile(this.x + this.width/2, this.y + this.height/2, angle, this, 'enemy'));
                }

                draw(ctx) {
                    const drawX = this.x;
                    const drawY = this.y;
                    ctx.strokeStyle = this.bleedTicks > 0 ? '#a22c2c' : '#FFFFFF';
                    ctx.fillStyle = '#333';
                    ctx.lineWidth = 2;

                    // Ghostly shape
                    ctx.beginPath();
                    ctx.moveTo(drawX, drawY + this.height);
                    ctx.quadraticCurveTo(drawX + this.width / 2, drawY + this.height / 2, drawX + this.width, drawY + this.height);
                    ctx.quadraticCurveTo(drawX + this.width / 2, drawY - this.height * 0.2, drawX, drawY + this.height);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    // Eye
                    ctx.fillStyle = '#FF4136';
                    ctx.beginPath();
                    ctx.arc(drawX + this.width / 2, drawY + this.height / 2, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    if (this.hp < this.maxHp) {
                        ctx.fillStyle = '#FF4136';
                        ctx.fillRect(drawX, drawY - 10, this.width, 5);
                        ctx.fillStyle = '#2ECC40';
                        ctx.fillRect(drawX, drawY - 10, this.width * (this.hp / this.maxHp), 5);
                    }
                }

                takeDamage(amount, isBleed = false) {
                    this.hp -= amount;
                    if (!isBleed) {
                        for(let i=0; i<3; i++) particles.push(new Particle(this.x + this.width/2, this.y + this.height/2, '#FFFFFF'));
                    }
                }
            }
            
            class Boss extends Enemy {
                constructor(x, y) {
                    super(x, y, 100);
                    this.width = 200; this.height = 200;
                    this.maxHp = 20000; this.hp = this.maxHp;
                    this.damage = 100; this.xpValue = 10000;
                    this.attackTimer = 0;
                    this.attackPattern = 'strafe';
                    this.patternDuration = 0;
                    this.chargeTarget = null;
                    this.strafeDirection = 1;
                    this.stats.projectileDamage = 30;
                }

                update(deltaTime) {
                    this.attackTimer += deltaTime;
                    this.patternDuration -= deltaTime;

                    if (this.patternDuration <= 0) {
                        const patterns = ['rain', 'charge', 'summon', 'strafe'];
                        this.attackPattern = patterns[Math.floor(Math.random() * patterns.length)];
                        this.patternDuration = 8 + Math.random() * 4;
                        this.chargeTarget = null;
                    }

                    switch (this.attackPattern) {
                        case 'strafe':
                            const idealDist = 400;
                            const distToPlayer = Math.hypot(player.x - this.x, player.y - this.y);
                            const angleToPlayer = Math.atan2(player.y - this.y, player.x - this.x);
                            
                            if (distToPlayer > idealDist + 50) {
                                this.x += Math.cos(angleToPlayer) * this.speed * 0.5;
                                this.y += Math.sin(angleToPlayer) * this.speed * 0.5;
                            } else if (distToPlayer < idealDist - 50) {
                                this.x -= Math.cos(angleToPlayer) * this.speed * 0.5;
                                this.y -= Math.sin(angleToPlayer) * this.speed * 0.5;
                            }

                            this.x += Math.cos(angleToPlayer + Math.PI/2) * this.speed * 0.3 * this.strafeDirection;
                            if (Math.random() < 0.01) this.strafeDirection *= -1;

                            if (this.attackTimer > 0.5) {
                                this.shoot(angleToPlayer);
                                this.attackTimer = 0;
                            }
                            break;

                        case 'rain':
                            if (this.attackTimer > 0.1) {
                                 const p = new Projectile(player.x + (Math.random() - 0.5) * 400, this.y - 600, Math.PI / 2, this, 'enemy');
                                 projectiles.push(p);
                                 this.attackTimer = 0;
                            }
                            break;

                        case 'charge':
                            if (!this.chargeTarget) {
                                this.chargeTarget = {x: player.x, y: player.y};
                                this.patternDuration = 3;
                            }
                            const angle = Math.atan2(this.chargeTarget.y - this.y, this.chargeTarget.x - this.x);
                            this.x += Math.cos(angle) * this.speed * 2.5;
                            this.y += Math.sin(angle) * this.speed * 2.5;
                            if (Math.hypot(this.x - this.chargeTarget.x, this.y - this.chargeTarget.y) < 50) {
                                this.chargeTarget = null;
                                this.patternDuration = 0;
                            }
                            break;

                        case 'summon':
                            if (this.attackTimer > 2) {
                                for(let i=0; i<3; i++) {
                                    enemies.push(new Enemy(this.x, this.y, waveManager.currentWave));
                                }
                                this.attackTimer = 0;
                            }
                            break;
                    }
                }

                draw(ctx) {
                    const drawX = this.x;
                    const drawY = this.y;
                    const time = gameTime / 1000;
                    
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.fillStyle = '#111';
                    ctx.lineWidth = 4;

                    // Spectral Bull Skull
                    // Main skull
                    ctx.beginPath();
                    ctx.moveTo(drawX + this.width * 0.2, drawY + this.height * 0.2);
                    ctx.quadraticCurveTo(drawX + this.width/2, drawY, drawX + this.width * 0.8, drawY + this.height * 0.2);
                    ctx.quadraticCurveTo(drawX + this.width, drawY + this.height/2, drawX + this.width * 0.8, drawY + this.height * 0.8);
                    ctx.lineTo(drawX + this.width/2, drawY + this.height);
                    ctx.lineTo(drawX + this.width * 0.2, drawY + this.height * 0.8);
                    ctx.quadraticCurveTo(drawX, drawY + this.height/2, drawX + this.width * 0.2, drawY + this.height * 0.2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    // Horns
                    ctx.beginPath();
                    ctx.moveTo(drawX + this.width * 0.2, drawY + this.height * 0.2);
                    ctx.quadraticCurveTo(drawX - 50, drawY - 50, drawX + this.width * 0.3, drawY - 60);
                    ctx.moveTo(drawX + this.width * 0.8, drawY + this.height * 0.2);
                    ctx.quadraticCurveTo(drawX + this.width + 50, drawY - 50, drawX + this.width * 0.7, drawY - 60);
                    ctx.stroke();

                    // Eyes
                    const pulse = Math.sin(time * 5) * 5 + 5;
                    ctx.fillStyle = '#FF4136';
                    ctx.beginPath();
                    ctx.arc(drawX + this.width * 0.35, drawY + this.height * 0.4, 15 + pulse, 0, Math.PI * 2);
                    ctx.arc(drawX + this.width * 0.65, drawY + this.height * 0.4, 15 + pulse, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            class Platform { constructor(x, y, width) { this.x = x; this.y = y; this.width = width; this.height = 10; } draw(ctx) { ctx.strokeStyle = '#FFFFFF'; ctx.lineWidth = 2; ctx.strokeRect(this.x, this.y, this.width, this.height); } }
            class Particle { constructor(x, y, color) { this.x = x; this.y = y; this.vx = (Math.random() - 0.5) * 4; this.vy = (Math.random() - 0.5) * 4; this.ttl = 30 + Math.random() * 30; this.color = color; this.radius = Math.random() * 2 + 1; } update() { this.x += this.vx; this.y += this.vy; this.ttl--; } draw(ctx) { ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); } }
            class Wisp { constructor(owner) { this.owner = owner; this.angle = 0; this.distance = 80; this.lastShot = 0; } update() { this.angle += 0.05; this.x = this.owner.x + this.owner.width / 2 + Math.cos(this.angle) * this.distance; this.y = this.owner.y + this.owner.height / 2 + Math.sin(this.angle) * this.distance; const now = Date.now(); if (now - this.lastShot > (this.owner.stats.attackSpeed * this.owner.stats.attackSpeedMultiplier) * 2) { let closestTarget = null; let minDistance = Infinity; enemies.forEach(e => { const dist = Math.hypot(e.x - this.x, e.y - this.y); if (dist < minDistance) { minDistance = dist; closestTarget = e; } }); if (closestTarget) { const angle = Math.atan2(closestTarget.y - this.y, closestTarget.x - this.x); const p = new Projectile(this.x, this.y, angle, { stats: { ...this.owner.stats, projectileDamage: this.owner.stats.projectileDamage / 2 } }, 'player'); projectiles.push(p); this.lastShot = now; } } } draw(ctx) { ctx.fillStyle = '#7FDBFF'; ctx.beginPath(); ctx.arc(this.x, this.y, 10, 0, Math.PI * 2); ctx.fill(); } }
            class Orb { constructor(x, y) { this.x = x; this.y = y; this.radius = 8; } update() { if (player && Math.hypot(this.x - player.x, this.y - player.y) < 100) { const angle = Math.atan2(player.y - this.y, player.x - this.x); this.x += Math.cos(angle) * 5; this.y += Math.sin(angle) * 5; } } draw(ctx) { ctx.fillStyle = '#2ECC40'; ctx.strokeStyle = '#FFFFFF'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); } }
            class Camera { constructor() { this.x = 0; this.y = 0; this.width = ui.canvas.width; this.height = ui.canvas.height; } follow(target) { if(!target) return; this.x = target.x + target.width / 2 - this.width / 2; this.y = target.y + target.height / 2 - this.height / 2; this.x = Math.max(0, Math.min(this.x, WORLD_WIDTH - this.width)); this.y = Math.max(-WORLD_HEIGHT + this.height, this.y); } }
            class WaveManager { constructor() { this.currentWave = 1; this.enemiesToSpawn = 5; this.spawning = false; } startNextWave() { if (this.spawning || bossSpawned) return; this.spawning = true; waveTime = gameTime; ui.waveNumber.textContent = `Onda: ${this.currentWave}`; for (let i = 0; i < this.enemiesToSpawn; i++) { const side = Math.random(); let x, y; if (side < 0.25) { x = player.x - ui.canvas.width / 2 - 50; y = player.y + (Math.random() * ui.canvas.height - ui.canvas.height / 2); } else if (side < 0.5) { x = player.x + ui.canvas.width / 2 + 50; y = player.y + (Math.random() * ui.canvas.height - ui.canvas.height / 2); } else if (side < 0.75) { x = player.x + (Math.random() * ui.canvas.width - ui.canvas.width / 2); y = player.y - ui.canvas.height / 2 - 50; } else { x = player.x + (Math.random() * ui.canvas.width - ui.canvas.width / 2); y = player.y + ui.canvas.height / 2 + 50; } enemies.push(new Enemy(x, y, this.currentWave)); } this.spawning = false; } update() { if (enemies.length === 0 && !this.spawning && !bossSpawned) { const timeTaken = (gameTime - waveTime) / 1000; let silverReward = (5 + 2 * this.currentWave) * player.stats.coinMultiplier; let goldReward = Math.floor(this.currentWave / 10) * player.stats.coinMultiplier; if (timeTaken < 20) { silverReward *= 4; goldReward = Math.max(1, goldReward * 2); } else if (timeTaken < 40) { silverReward *= 2; } player.stats.silver += Math.floor(silverReward); player.stats.gold += Math.floor(goldReward); this.currentWave++; this.enemiesToSpawn = Math.floor(5 + this.currentWave * 1.5); this.startNextWave(); } } }

            // --- GAME LOGIC ---
            function initAndStartGame() {
                resizeCanvas();
                projectiles = []; enemies = []; particles = []; platforms = []; wisps = []; orbs = [];
                gameTime = 0; lastTime = 0; boss = null; bossSpawned = false; godMode = false;

                player = new Player(WORLD_WIDTH / 2, -100);
                const savedData = loadGameData();
                if (savedData) {
                    player.applyLoadedData(savedData);
                }
                
                // Reset and apply skin ability
                player.stats.damageMultiplier = 1;
                player.stats.passiveRegen = 0;
                player.stats.coinMultiplier = 1;
                const skinAbility = SKINS[player.stats.equippedSkin]?.ability;
                if (skinAbility) {
                    skinAbility(player);
                }

                camera = new Camera();
                waveManager = new WaveManager();
                
                // Generate Map
                platforms.push(new Platform(0, 0, WORLD_WIDTH));
                let lastY = 0;
                for (let i = 0; i < 500; i++) {
                    const platformWidth = Math.random() * 350 + 250;
                    const x = Math.random() * (WORLD_WIDTH - platformWidth);
                    const y = lastY - (Math.random() * 120 + 100);
                    platforms.push(new Platform(x, y, platformWidth));
                    lastY = y;
                }
                
                // Generate background
                backgroundLayers = [];
                for (let i = 0; i < 3; i++) {
                    let layer = {
                        stars: [],
                        speed: 0.2 + i * 0.2,
                        color: `rgba(255, 255, 255, ${0.1 + i * 0.15})`
                    };
                    for (let j = 0; j < 100; j++) {
                        layer.stars.push({
                            x: Math.random() * WORLD_WIDTH,
                            y: Math.random() * -WORLD_HEIGHT,
                            r: Math.random() * (i + 1)
                        });
                    }
                    backgroundLayers.push(layer);
                }

                waveManager.startNextWave();
                setGameState('IN_GAME');
            }

            function gameLoop(timestamp) {
                if (gameState !== 'IN_GAME') {
                    if (gameLoopId) cancelAnimationFrame(gameLoopId);
                    gameLoopId = null;
                    return;
                }
                
                const deltaTime = (timestamp - lastTime) / 1000 || 0;
                lastTime = timestamp;
                gameTime += deltaTime * 1000;

                // --- UPDATE ---
                player.update(deltaTime);
                enemies.forEach(e => e.update(deltaTime));
                projectiles.forEach(p => p.update());
                particles.forEach(p => p.update());
                wisps.forEach(w => w.update());
                orbs.forEach(o => o.update());
                if (boss) boss.update(deltaTime);
                if (!bossSpawned) waveManager.update();
                camera.follow(player);

                // --- COLLISIONS ---
                handleCollisions();
                
                // --- CLEANUP ---
                projectiles = projectiles.filter(p => p.ttl > 0 && p.x > camera.x - 200 && p.x < camera.x + camera.width + 200);
                particles = particles.filter(p => p.ttl > 0);
                enemies = enemies.filter(e => e.hp > 0);
                
                // --- DRAW ---
                ui.ctx.clearRect(0, 0, ui.canvas.width, ui.canvas.height);
                
                if (screenShake > 0) {
                    ui.ctx.save();
                    const shakeX = (Math.random() - 0.5) * screenShake;
                    const shakeY = (Math.random() - 0.5) * screenShake;
                    ui.ctx.translate(shakeX, shakeY);
                    screenShake *= 0.9;
                }
                
                ui.ctx.save();
                ui.ctx.translate(-camera.x, -camera.y);

                // Draw background
                drawBackground();

                platforms.forEach(p => p.draw(ui.ctx));
                
                // Draw projectile lights
                drawLights();
                
                player.draw(ui.ctx);
                enemies.forEach(e => e.draw(ui.ctx));
                projectiles.forEach(p => p.draw(ui.ctx));
                particles.forEach(p => p.draw(ui.ctx));
                wisps.forEach(w => w.draw(ui.ctx));
                orbs.forEach(o => o.draw(ui.ctx));
                if (boss) boss.draw(ui.ctx);

                ui.ctx.restore();
                
                if (screenShake > 0) {
                    ui.ctx.restore();
                }
                
                updateGameUI();
                gameLoopId = requestAnimationFrame(gameLoop);
            }

            function drawBackground() {
                backgroundLayers.forEach(layer => {
                    ui.ctx.fillStyle = layer.color;
                    layer.stars.forEach(star => {
                        const x = (star.x - camera.x * layer.speed) % WORLD_WIDTH;
                        const y = (star.y - camera.y * layer.speed);
                        ui.ctx.fillRect(x, y, star.r * 2, star.r * 2);
                    });
                });
            }

            function drawLights() {
                ui.ctx.globalCompositeOperation = 'lighter';
                projectiles.forEach(p => {
                    const grad = ui.ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.lightRadius);
                    const color = p.ownerType === 'enemy' ? '255, 100, 100' : '255, 255, 255';
                    grad.addColorStop(0, `rgba(${color}, 0.3)`);
                    grad.addColorStop(1, `rgba(${color}, 0)`);
                    ui.ctx.fillStyle = grad;
                    ui.ctx.beginPath();
                    ui.ctx.arc(p.x, p.y, p.lightRadius, 0, Math.PI * 2);
                    ui.ctx.fill();
                });
                ui.ctx.globalCompositeOperation = 'source-over';
            }


            function handleCollisions() {
                projectiles.forEach((p, pi) => {
                    if (p.ownerType === 'player') {
                        const targets = [...enemies, ...(boss ? [boss] : [])];
                        for (const e of targets) {
                            if (checkCollision(p, e)) {
                                const damageDealt = p.damage;
                                e.takeDamage(damageDealt);
                                if (player.stats.lifesteal > 0) player.heal(damageDealt * player.stats.lifesteal);
                                if (player.stats.slowOnHit > 0) e.slowFactor = Math.max(0.2, e.slowFactor - player.stats.slowOnHit);
                                if (player.stats.bleedChance > 0 && Math.random() < player.stats.bleedChance) {
                                    e.bleedTicks = 180; e.bleedDamage = damageDealt * 0.1;
                                }
                                p.piercingLeft--;
                                if (p.piercingLeft <= 0) {
                                    projectiles.splice(pi, 1);
                                    break;
                                }
                            }
                        }
                    } else if (p.ownerType === 'enemy' || p.ownerType === 'fragment') {
                        if (checkCollision(p, player)) {
                            player.takeDamage(p.damage);
                            projectiles.splice(pi, 1);
                        }
                    }
                });

                const allAttackers = [...enemies, ...(boss ? [boss] : [])];
                allAttackers.forEach(e => {
                    if (checkCollision(player, e)) {
                        player.takeDamage(e.damage);
                    }
                });

                let newEnemies = [];
                enemies.forEach((e, ei) => {
                    if (e.hp <= 0) {
                        player.addXp(e.xpValue);
                        if (player.stats.healOrbChance > 0 && Math.random() < player.stats.healOrbChance) {
                            orbs.push(new Orb(e.x, e.y));
                        }
                        if (player.stats.enemyFragmentation > 0) {
                            for(let i=0; i<player.stats.enemyFragmentation; i++) {
                                const p = new Projectile(e.x + e.width/2, e.y + e.height/2, Math.random() * Math.PI * 2, {stats: {projectileDamage: 5}}, 'fragment');
                                projectiles.push(p);
                            }
                        }
                    } else {
                        newEnemies.push(e);
                    }
                });
                enemies = newEnemies;

                orbs.forEach((o, oi) => {
                    if (checkCollision(player, o)) {
                        player.heal(player.stats.maxHp * 0.1);
                        orbs.splice(oi, 1);
                    }
                });
                
                if (boss && boss.hp <= 0) {
                    setGameState('VICTORY');
                    boss = null;
                    bossSpawned = false;
                }
            }
            
            function spawnBoss() {
                if (bossSpawned) return;
                bossSpawned = true;
                enemies = [];
                waveManager.spawning = true;
                boss = new Boss(player.x, player.y - 800);
                ui.bossHealthBar.classList.remove('hidden');
                ui.waveNumber.textContent = "CHEFE FINAL";
                screenShake = 20;
            }

            function setGameState(newState) {
                const wasInGame = (gameState === 'IN_GAME');
                gameState = newState;
                
                if (newState !== 'IN_GAME' && gameLoopId) {
                    cancelAnimationFrame(gameLoopId);
                    gameLoopId = null;
                }
                
                const overlays = document.querySelectorAll('.ui-overlay, #debug-menu');
                overlays.forEach(el => el.classList.add('hidden'));
                ui.inGameUI.classList.add('hidden');

                switch(newState) {
                    case 'MAIN_MENU': ui.mainMenu.classList.remove('hidden'); break;
                    case 'SHOOTING_MODE': ui.shootingModeMenu.classList.remove('hidden'); break;
                    case 'SHOP': displayShop(); ui.shopMenu.classList.remove('hidden'); break;
                    case 'CUSTOMIZATION': displayCustomization(); ui.customizationMenu.classList.remove('hidden'); break;
                    case 'LEADERBOARD': displayLeaderboard(); ui.leaderboardScreen.classList.remove('hidden'); break;
                    case 'IN_GAME':
                        ui.inGameUI.classList.remove('hidden');
                        if (boss) ui.bossHealthBar.classList.remove('hidden');
                        if (!gameLoopId) {
                            lastTime = performance.now();
                            gameLoopId = requestAnimationFrame(gameLoop);
                        }
                        break;
                    case 'PAUSED':
                        ui.pauseMenu.classList.remove('hidden');
                        ui.inGameUI.classList.remove('hidden');
                        if (boss) ui.bossHealthBar.classList.remove('hidden');
                        break;
                    case 'LEVEL_UP':
                        displayUpgradeOptions();
                        ui.upgradeScreen.classList.remove('hidden');
                        ui.inGameUI.classList.remove('hidden');
                        break;
                    case 'GAME_OVER':
                        saveGameData();
                        document.getElementById('game-over-stats').innerText = `Você sobreviveu até a Onda ${waveManager.currentWave} e alcançou o Nível ${player.level}.`;
                        ui.gameOverScreen.classList.remove('hidden');
                        break;
                    case 'VICTORY':
                        saveGameData();
                        const timeStr = formatTime(gameTime);
                        document.getElementById('victory-stats').innerText = `Onda Final: ${waveManager.currentWave} | Nível: ${player.level} | Tempo: ${timeStr}`;
                        ui.victoryScreen.classList.remove('hidden');
                        break;
                }
            }
            
            // --- UI & MENU FUNCTIONS ---

            function displayUpgradeOptions() {
                ui.upgradeScreen.innerHTML = '';
                ui.upgradeScreen.className = 'ui-overlay upgrade-grid-layout'; // Apply grid layout
                let availableUpgrades = Object.values(UPGRADES);
                
                // Filter out Appraisal if player already has max choices
                if (player.stats.upgradeChoices >= 6) {
                    availableUpgrades = availableUpgrades.filter(up => up.name !== "Appraisal");
                }

                let choices = [];
                const numChoices = Math.min(player.stats.upgradeChoices, 6); // Cap choices at 6

                for (let i = 0; i < numChoices; i++) {
                    if (availableUpgrades.length === 0) break;
                    
                    let weightedList = [];
                    availableUpgrades.forEach(up => {
                        let weight = 0;
                        if (up.rarity === 'Common') weight = 10;
                        if (up.rarity === 'Uncommon') weight = 5;
                        if (up.rarity === 'Rare') weight = 2;
                        weight *= (1 + player.stats.luck);
                        for(let j=0; j<weight; j++) weightedList.push(up);
                    });
                    
                    const choice = weightedList[Math.floor(Math.random() * weightedList.length)];
                    choices.push(choice);
                    availableUpgrades = availableUpgrades.filter(up => up.name !== choice.name);
                }

                choices.forEach(upgrade => {
                    const card = document.createElement('div');
                    card.className = `upgrade-card rarity-${upgrade.rarity}`;
                    card.innerHTML = `<h3>${upgrade.name}</h3><p>${upgrade.desc}</p><div class="rarity">${upgrade.rarity}</div>`;
                    card.onclick = () => {
                        player.applyUpgrade(upgrade);
                        setGameState('IN_GAME');
                    };
                    ui.upgradeScreen.appendChild(card);
                });
            }

            function displayShop() {
                const data = loadGameData();
                const content = document.getElementById('shop-content');
                content.innerHTML = `<h2>Armas</h2><div class="shop-grid" id="shop-weapons"></div><h2>Skins</h2><div class="shop-grid" id="shop-skins"></div>`;
                
                const weaponsGrid = document.getElementById('shop-weapons');
                Object.keys(WEAPONS).forEach(id => {
                    const item = WEAPONS[id];
                    if (item.price === 0) return;
                    const card = document.createElement('div');
                    card.className = 'item-card';
                    const isUnlocked = data.unlockedWeapons.includes(id);
                    const canAfford = item.currency === 'silver' ? data.silver >= item.price : data.gold >= item.price;
                    card.innerHTML = `<h3>${item.name}</h3><p>${item.desc}</p><div class="price ${item.currency === 'silver' ? 'price-silver' : 'price-gold'}">${item.price} ${item.currency}</div>
                                      <button class="shop-button" onclick="window.buyItem('${id}', 'weapon')" ${isUnlocked || !canAfford ? 'disabled' : ''}>
                                      ${isUnlocked ? 'Comprado' : 'Comprar'}</button>`;
                    weaponsGrid.appendChild(card);
                });
                const skinsGrid = document.getElementById('shop-skins');
                Object.keys(SKINS).forEach(id => {
                    const item = SKINS[id];
                    if (item.price === 0) return;
                    const card = document.createElement('div');
                    card.className = 'item-card';
                    const isUnlocked = data.unlockedSkins.includes(id);
                    const canAfford = item.currency === 'silver' ? data.silver >= item.price : data.gold >= item.price;
                    card.innerHTML = `<h3>${item.name}</h3><div class="price ${item.currency === 'silver' ? 'price-silver' : 'price-gold'}">${item.price} ${item.currency}</div>
                                      <button class="shop-button" onclick="window.buyItem('${id}', 'skin')" ${isUnlocked || !canAfford ? 'disabled' : ''}>
                                      ${isUnlocked ? 'Comprado' : 'Comprar'}</button>`;
                    skinsGrid.appendChild(card);
                });
            }

            window.buyItem = (id, type) => {
                const data = loadGameData();
                const item = type === 'weapon' ? WEAPONS[id] : SKINS[id];
                
                const canAfford = item.currency === 'silver' ? data.silver >= item.price : data.gold >= item.price;
                const isUnlocked = type === 'weapon' ? data.unlockedWeapons.includes(id) : data.unlockedSkins.includes(id);

                if (!isUnlocked && canAfford) {
                    if (item.currency === 'silver') data.silver -= item.price;
                    else data.gold -= item.price;
                    
                    if (type === 'weapon') data.unlockedWeapons.push(id);
                    else data.unlockedSkins.push(id);

                    saveGameData(data);
                    displayShop();
                }
            }

            function displayCustomization() {
                const data = loadGameData();
                const content = document.getElementById('customization-content');
                content.innerHTML = `<h2>Equipar Arma</h2><div class="customization-grid" id="custom-weapons"></div><h2>Equipar Skin</h2><div class="customization-grid" id="custom-skins"></div>`;

                const weaponsGrid = document.getElementById('custom-weapons');
                data.unlockedWeapons.forEach(id => {
                    const item = WEAPONS[id];
                    const card = document.createElement('div');
                    card.className = `item-card ${data.equippedWeapon === id ? 'equipped' : ''}`;
                    card.innerHTML = `<h3>${item.name}</h3><p>${item.desc}</p><button class="shop-button" onclick="window.equipItem('${id}', 'weapon')">Equipar</button>`;
                    weaponsGrid.appendChild(card);
                });
                const skinsGrid = document.getElementById('custom-skins');
                data.unlockedSkins.forEach(id => {
                    const item = SKINS[id];
                    const card = document.createElement('div');
                    card.className = `item-card ${data.equippedSkin === id ? 'equipped' : ''}`;
                    card.innerHTML = `<h3>${item.name}</h3><button class="shop-button" onclick="window.equipItem('${id}', 'skin')">Equipar</button>`;
                    skinsGrid.appendChild(card);
                });
            }
            
            window.equipItem = (id, type) => {
                const data = loadGameData();
                if (type === 'weapon') data.equippedWeapon = id;
                if (type === 'skin') data.equippedSkin = id;
                saveGameData(data);
                displayCustomization();
            }
            
            function setupDebugMenu() {
                const select = document.getElementById('debug-upgrade-select');
                if (!select) return;
                select.innerHTML = ''; // Clear previous options
                Object.keys(UPGRADES).forEach(key => {
                    const option = document.createElement('option');
                    option.value = key;
                    option.textContent = UPGRADES[key].name;
                    select.appendChild(option);
                });
            }

            // --- HELPER & DATA FUNCTIONS ---

            function saveGameData(dataToSave = null) {
                const currentData = player ? {
                    silver: player.stats.silver, gold: player.stats.gold,
                    unlockedSkins: player.stats.unlockedSkins, unlockedWeapons: player.stats.unlockedWeapons,
                    equippedSkin: player.stats.equippedSkin, equippedWeapon: player.stats.equippedWeapon
                } : loadGameData();
                const data = dataToSave || currentData;
                localStorage.setItem('arcanistAscensionSave', JSON.stringify(data));
            }

            function loadGameData() {
                const saved = localStorage.getItem('arcanistAscensionSave');
                if (saved) return JSON.parse(saved);
                return { silver: 0, gold: 0, unlockedSkins: ['default'], unlockedWeapons: ['default'], equippedSkin: 'default', equippedWeapon: 'default' };
            }
            
            function saveScore(name) { 
                const scores = JSON.parse(localStorage.getItem('arcanistLeaderboard')) || []; 
                const newScore = { name: name, wave: waveManager.currentWave, time: gameTime, status: boss && boss.hp <= 0 ? "Venceu" : "Derrotado" }; 
                scores.push(newScore); 
                scores.sort((a, b) => {
                    if (a.status === 'Venceu' && b.status !== 'Venceu') return -1;
                    if (b.status === 'Venceu' && a.status !== 'Venceu') return 1;
                    if (a.status === 'Venceu' && b.status === 'Venceu') return a.time - b.time;
                    return b.wave - a.wave || a.time - b.time;
                }); 
                localStorage.setItem('arcanistLeaderboard', JSON.stringify(scores.slice(0, 10))); 
            }

            function displayLeaderboard() { 
                const scores = JSON.parse(localStorage.getItem('arcanistLeaderboard')) || []; 
                const tbody = document.getElementById('leaderboard-body'); 
                tbody.innerHTML = ''; 
                scores.forEach((score, index) => { 
                    const row = tbody.insertRow(); 
                    row.innerHTML = `<td>${index + 1}</td><td>${score.name}</td><td>${score.wave}</td><td>${formatTime(score.time)}</td><td>${score.status}</td>`; 
                }); 
            }

            function formatTime(ms) { const minutes = Math.floor(ms / 60000); const seconds = Math.floor((ms % 60000) / 1000); return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`; }
            function updateGameUI() { if(!player) return; ui.healthBarFill.style.width = `${(player.hp / player.stats.maxHp) * 100}%`; ui.xpBarFill.style.width = `${(player.xp / player.xpToNextLevel) * 100}%`; ui.waveTimer.textContent = `Tempo: ${formatTime(gameTime)}`; if (boss) { ui.bossHealthBarFill.style.width = `${(boss.hp / boss.maxHp) * 100}%`; } updateStatsUI(); updateCurrencyUI(); }
            function updateStatsUI() { if (!player) return; ui.statsDisplay.innerHTML = `Lvl: ${player.level} | HP: ${Math.ceil(player.hp)}/${player.stats.maxHp}<br>Atk: ${(1 / (player.stats.attackSpeed * player.stats.attackSpeedMultiplier * (1 - player.focusBonus) / 1000)).toFixed(2)}/s | Dano: ${(player.stats.projectileDamage * player.stats.damageMultiplier).toFixed(0)}`; }
            function updateCurrencyUI() { const data = player ? player.stats : loadGameData(); ui.silverCoins.textContent = `Prata: ${data.silver}`; ui.goldCoins.textContent = `Ouro: ${data.gold}`; }
            function checkCollision(obj1, obj2) { if (!obj1 || !obj2) return false; const r1 = { x: obj1.x, y: obj1.y, width: obj1.width || obj1.radius * 2, height: obj1.height || obj1.radius * 2 }; const r2 = { x: obj2.x, y: obj2.y, width: obj2.width || obj2.radius * 2, height: obj2.height || obj2.radius * 2 }; return r1.x < r2.x + r2.width && r1.x + r1.width > r2.x && r1.y < r2.y + r2.height && r1.y + r1.height > r2.y; }
            function resizeCanvas() { ui.canvas.width = ui.container.clientWidth; ui.canvas.height = ui.container.clientHeight; if (camera) { camera.width = ui.canvas.width; camera.height = ui.canvas.height; } }

            // --- EVENT LISTENERS ---
            document.getElementById('start-game-btn').addEventListener('click', () => setGameState('SHOOTING_MODE'));
            document.getElementById('confirm-shooting-mode-btn').addEventListener('click', () => initAndStartGame());
            document.getElementById('back-to-main-from-shooting-btn').addEventListener('click', () => setGameState('MAIN_MENU'));
            document.getElementById('shop-btn').addEventListener('click', () => setGameState('SHOP'));
            document.getElementById('customization-btn').addEventListener('click', () => setGameState('CUSTOMIZATION'));
            document.getElementById('back-to-main-from-shop-btn').addEventListener('click', () => setGameState('MAIN_MENU'));
            document.getElementById('back-to-main-from-custom-btn').addEventListener('click', () => setGameState('MAIN_MENU'));
            document.getElementById('exit-to-main-btn').addEventListener('click', () => { saveGameData(); setGameState('MAIN_MENU'); });
            document.getElementById('resume-game-btn').addEventListener('click', () => setGameState('IN_GAME'));
            document.getElementById('restart-game-btn').addEventListener('click', () => initAndStartGame());
            document.getElementById('game-over-to-main-btn').addEventListener('click', () => setGameState('MAIN_MENU'));
            document.getElementById('leaderboard-btn').addEventListener('click', () => setGameState('LEADERBOARD'));
            document.getElementById('leaderboard-back-btn').addEventListener('click', () => setGameState('MAIN_MENU'));
            document.getElementById('submit-score-btn').addEventListener('click', () => { const name = document.getElementById('leaderboard-name-input').value || "Anônimo"; saveScore(name); setGameState('LEADERBOARD'); });
            
            // Debug Listeners
            document.getElementById('submit-debug-code-btn').addEventListener('click', () => {
                const input = document.getElementById('debug-code-input');
                if (input.value.toUpperCase() === DEBUG_CODE) {
                    ui.debugMenu.classList.remove('hidden');
                    ui.debugPrompt.classList.add('hidden');
                    setupDebugMenu();
                }
                input.value = '';
            });
            document.getElementById('cancel-debug-prompt-btn').addEventListener('click', () => { ui.debugPrompt.classList.add('hidden'); setGameState('IN_GAME'); });
            document.getElementById('close-debug-menu-btn').addEventListener('click', () => ui.debugMenu.classList.add('hidden'));
            document.getElementById('add-xp-btn').addEventListener('click', () => { if(player) player.addXp(1000); });
            document.getElementById('add-coins-btn').addEventListener('click', () => { if(player) { player.stats.silver += 10000; player.stats.gold += 1000; } });
            document.getElementById('heal-player-btn').addEventListener('click', () => { if(player) player.heal(player.stats.maxHp); });
            document.getElementById('kill-enemies-btn').addEventListener('click', () => { enemies = []; if(boss) boss.hp = 0; });
            document.getElementById('spawn-boss-btn').addEventListener('click', () => spawnBoss());
            document.getElementById('toggle-god-mode-btn').addEventListener('click', (e) => { godMode = !godMode; e.target.textContent = `God Mode: ${godMode ? 'ON' : 'OFF'}`; });
            document.getElementById('add-upgrade-btn').addEventListener('click', () => {
                if (!player) return;
                const select = document.getElementById('debug-upgrade-select');
                const upgradeKey = select.value;
                if (upgradeKey && UPGRADES[upgradeKey]) {
                    player.applyUpgrade(UPGRADES[upgradeKey]);
                }
            });
            document.getElementById('goto-wave-btn').addEventListener('click', () => {
                if (!waveManager) return;
                const waveInput = document.getElementById('debug-wave-input');
                const wave = parseInt(waveInput.value, 10);
                if (!isNaN(wave) && wave > 0) {
                    waveManager.currentWave = wave;
                    enemies = []; // Clear current enemies to start the new wave
                    waveManager.spawning = false; // Force wave manager to check for next wave
                }
            });
            document.getElementById('give-all-upgrades-btn').addEventListener('click', () => {
                if (!player) return;
                for (const key in UPGRADES) {
                    // Avoid applying Appraisal multiple times if it's not desired
                    if (UPGRADES[key].name === "Appraisal" && player.stats.upgradeChoices >= 6) continue;
                    player.applyUpgrade(UPGRADES[key]);
                }
            });


            // Global Listeners
            window.addEventListener('resize', resizeCanvas);
            document.addEventListener('keydown', (e) => { 
                keys[e.key.toLowerCase()] = true; 
                if (e.key.toLowerCase() === 'p' && gameState === 'IN_GAME') setGameState('PAUSED');
                else if (e.key.toLowerCase() === 'p' && gameState === 'PAUSED') setGameState('IN_GAME');
                if (e.key.toLowerCase() === 'c' && (gameState === 'IN_GAME' || gameState === 'PAUSED')) { 
                    setGameState('PAUSED'); 
                    ui.debugPrompt.classList.remove('hidden');
                    document.getElementById('debug-code-input').focus();
                } 
            });
            document.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });
            ui.canvas.addEventListener('mousemove', (e) => { const rect = ui.canvas.getBoundingClientRect(); mouse.x = e.clientX - rect.left; mouse.y = e.clientY - rect.top; });
            ui.canvas.addEventListener('mousedown', () => { mouse.down = true; });
            ui.canvas.addEventListener('mouseup', () => { mouse.down = false; });

            // --- INITIALIZE ---
            resizeCanvas();
            setGameState('MAIN_MENU');
            updateCurrencyUI();
        };
    </script>
</body>
</html>
